# Wordタイムスタンプのみ vs `[WORD: ]`タグ併用フロー

## 概要比較

### Wordタイムスタンプのみ
- LLMがテキストを整形後、推測マッチングでタイムスタンプを割り当てる方法
- 語尾変更やフィラー削除により、マッチングの精度が低下しやすい

### `[WORD: ]`タグ併用
- LLMが整形時にアンカー単語をタグとして明示的に付与
- タグを使って確実にタイムスタンプを参照できる

---

## フェーズ別詳細比較

### 1. 文字起こし

**両方式共通:**
- Whisper系モデルでword-levelタイムスタンプ付きテキストを生成

### 2. LLM整形

#### Wordタイムスタンプのみ
- LLMがフィラー削除・語尾調整を実施
- 整形後テキストのみを得る

#### `[WORD: ]`タグ併用
- LLMが整形しつつ各行末に`[WORD: 単語]`を付与
- アンカー情報を明示的に保持

### 3. 行分割チェック

#### Wordタイムスタンプのみ
- 整形結果から17文字制約を守るよう再分割
- どの単語がどの行に属するかは**推測に頼る**

#### `[WORD: ]`タグ併用
- タグをJSON化し、テキストと`anchor_word`を分離
- タグ削除後に17文字チェックを再実施
- 自動再分割してもアンカー情報は保持される

### 4. 行→単語マッチング

#### Wordタイムスタンプのみ
- LLMが削除/変更した単語により、どの単語のタイムスタンプを使うべきか推測マッチングが必要
- Fuzzy Matching中心の処理

#### `[WORD: ]`タグ併用
- `anchor_word`をキーにして直接タイムスタンプを参照
- 複数アンカー（先頭/中央/末尾）で照合精度を向上可能

### 5. タイムスタンプ確定

#### Wordタイムスタンプのみ
- マッチングが曖昧だと誤差が出やすい
- 語尾が変わると失敗する可能性あり

#### `[WORD: ]`タグ併用
- アンカー単語の`end`時刻をそのまま字幕終了時刻に採用
- 行間の調整も自動化しやすい

### 6. ログ/デバッグ

#### Wordタイムスタンプのみ
- 行と単語の対応が不明確
- どこでズレたか追跡しづらい

#### `[WORD: ]`タグ併用
- JSONの`anchor_word`や警告ログにより、問題箇所を即座に把握
- どの行でタグ情報が見つからなかったか明確

### 7. 表示品質

#### Wordタイムスタンプのみ
- タイミング重視のため、見た目の17文字制約が崩れやすい

#### `[WORD: ]`タグ併用
- タグを外しても17文字を再検証
- 視認性とタイミングの両方を維持可能

### 8. 失敗時対処

#### Wordタイムスタンプのみ
- 照合に失敗すると行全体のタイミングを推測で埋めるしかない
- 原因特定が困難

#### `[WORD: ]`タグ併用
- アンカーが見つからなければその行だけ警告
- 仮タイムスタンプを設定するなど細かい制御が可能

---

## 結論

### ❌ Wordタイムスタンプのみの問題点
- 「字幕行と原単語の対応付け」を毎回推測する必要がある
- リライトやフィラー削除を多用する本プロジェクトとは**相性が良くない**
- マッチング精度が低く、エラー追跡が困難

### ✅ `[WORD: ]`タグ併用の利点
- 表示テキストとタイムスタンプ管理を**完全に分離**できる
- アンカーを明示することで確実なタイムスタンプ参照が可能
- 非エンジニアでも安定した結果を得やすい
- デバッグとエラー追跡が容易

