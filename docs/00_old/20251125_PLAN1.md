# プランニングドキュメント：GUIアプリ（Flow Cut フロントエンド）

**作成日**: 2025-11-25  
**バージョン**: 1.1  
**ステータス**: 実装中（Phase 1 完了）  
**前バージョンからの変更**: Tkinter最小GUIの実装完了、SRT保存先選択機能・CLI `--subtitle-dir` 追加、python.org版3.12 + Tkinter前提を明文化

※このプランは、既存の CLI パイプライン（`src/pipeline/poc.py`）をそのまま流用しながら、GUIと将来のWeb UIを安全に増やしていくための設計・実装方針をまとめたものです。
# プランニングドキュメント：GUIアプリ（Flow Cut フロントエンド）実装

**作成日**: 2025-11-25  
**バージョン**: 1.0  
**ステータス**: ドラフト  
**前バージョンからの変更**: 新規作成（Phase4 GUIアプリ着手用のPLAN）

※このPLANに着手する前提として、既存の要件定義書 `docs/requirement.md`（特に「4. UI/UX 要件」）を一読していることを想定しています。

---

## ⚡ クイックリファレンス（引き継ぎ用）

> 新規エージェントが3分で状況を把握するためのサマリー

**現在地**: Phase 1 - `src/gui/app.py` / `src/gui/controller.py` で最小GUI（ファイル選択＋保存先選択＋実行）が完成（約40%完了）  
**次のアクション**: Phase 2 として「工程別ステータス表示（音声解析中 / AI思考中 / ファイル生成中）」をGUIに反映する設計と実装を進める。  
**ブロッカー**: なし（GUI実行には python.org 版 Python 3.12 + Tkinter が必要だが、開発環境では解消済み）  
**重要な決定事項**: コアロジックは `execute_poc_run` に集約し、GUI/CLI/Web いずれもこの関数を通して実行する（UIごとにロジックを複製しない）。

### フェーズ進捗
- [x] Phase 0: 設計・PLAN作成・環境方針整理 完了  
- [x] Phase 1: 最小GUI（ファイル選択＋実行ボタン＋保存先選択）（CLI `--subtitle-dir` 追加含む）  
- [ ] Phase 2: ステータス詳細化（工程別の進捗表示）  
- [ ] Phase 3: オプションUI（LLM選択、リライトON/OFF、高精度モード）  
- [ ] Phase 4: Web UI検討（API化＋ブラウザフロント）  

### 環境チェックリスト
- [x] python.org 版 Python 3.12 インストール済み（Tkinter同梱）  
- [x] `.venv-gui` など Tkinter対応Pythonで作った仮想環境がある  
- [x] `requirements-dev.txt` 導入済み  
- [x] Mac開発環境に `mlx-whisper` がインストール済み（MLX Whisper Large-v3 利用のため）  
- [ ] 友人配布用の `.app` パッケージングは未実施（Phase 4以降で検討）  
**現在地**: Phase 0 - 「GUI設計・技術選定」ドキュメント作成中（0%完了 / コード未着手）  
**次のアクション**: Tkinterベースで最小GUI（ファイル選択＋実行ボタン＋簡易ログ表示）を実装し、CLIパイプライン `execute_poc_run` をバックグラウンド実行できるようにする。  
**ブロッカー**: なし（Python 3.12 + Tkinter が標準で利用できる前提）  
**重要な決定事項**: 初期実装は **Tkinter + ttk** のシンプルなデスクトップGUIで行い、既存CLIパイプラインをそのまま呼び出す構成とする（Flet / Tauri + React は将来の拡張候補）。

### フェーズ進捗
- [ ] Phase 0: GUI設計・技術選定（このPLANの合意）  
- [ ] Phase 1: 最小GUI（ファイル選択＋実行ボタン＋ログ表示）  
- [ ] Phase 2: 進捗バー・ステータス表示・エラー表示整備  
- [ ] Phase 3: オプションUI（リライトON/OFF・高精度モードなど）  
- [ ] Phase 4: パッケージング準備（.app配布想定）とドキュメント更新  

### 環境チェックリスト
- [ ] Python 3.10〜3.12 + Tkinter 利用可能（macOS 標準）  
- [ ] `.venv` 作成済み ＆ `requirements-dev.txt` 導入済み  
- [ ] `.env` 設定済み（少なくとも LLM用 API キー / Whisper 設定）  

### 重要なファイルパス
- メインCLI: `src/cli/main.py`  
- パイプライン本体: `src/pipeline/poc.py`  
- GUIウィンドウ: `src/gui/app.py`  
- GUI用コントローラ: `src/gui/controller.py`  
- 要件定義: `docs/requirement.md`  
- 本PLAN: `docs/plan/20251125_PLAN1.md`

---

## 🔄 現在の作業状態

**最終更新**: 2025-11-25 22:00 JST  
**進捗率**: 約40%

### 直前の作業
- ✅ 完了: `src/gui/app.py` に最小GUI（ファイル選択・保存先フォルダ選択・実行ボタン・ステータス表示・簡易プログレスバー）を実装  
- ✅ 完了: `src/gui/controller.py` で `execute_poc_run` をバックグラウンドスレッドから呼び出す `GuiController` を実装  
- ✅ 完了: CLI `run` コマンドに `--subtitle-dir` を追加し、SRT保存先ディレクトリを指定できるようにした  
- ✅ 完了: `docs/requirement.md` / `docs/runbook.md` にGUI/CLIの出力仕様を反映  
- 🔄 作業中: Phase 2（工程別ステータス表示）の要件・UI設計（まだコードには着手していない）  
- ⏳ 次のタスク:  
  - LLMステータス（例: 「AI思考中…」）と音声解析の進捗をGUIにどうマッピングするかを整理  
  - 進捗を細かく見せるか、シンプルなメッセージにとどめるかを決める  

### ブロッカー・未解決の問題
- [ ] GUI と CLI の両方から長尺音声を実行したときの UX（時間がかかる間の見え方）をまだ十分検証できていない  
- [ ] `.app` 化したときに Gatekeeper まわりで発生しうる問題（未検証・TODO）  
- 文字起こしランナー: `src/transcribe/*.py`  
- LLM二段階整形: `src/llm/two_pass.py` / `src/llm/prompts.py`  
- SRT生成ユーティリティ: `src/alignment/srt.py`  
- GUI（新規予定）: `src/gui/app.py`, `src/gui/controller.py`, `src/gui/README.md`

---

## 🔄 現在の作業状態

**最終更新**: 2025-11-25 00:00 JST（PLAN作成時点）  
**進捗率**: 0%（GUIコードは未実装／設計のみ）

### 直前の作業
- ✅ 完了: CLIベースの two-pass パイプラインが要件定義どおり動作することを確認（文字起こし〜SRT出力まで）  
- 🔄 作業中: GUI実装用PLAN（本ドキュメント）の作成  
  - 残タスク: 各Phaseのタスク粒度を明確化し、実装時に迷わないレベルまで分解する  
  - 停止位置: 「実装フェーズ」セクションのToDo列挙まで  
- ⏳ 次のタスク: Phase 1 の「最小GUI」の実装に着手する前に、本PLANの内容をユーザーと軽くすり合わせる

### ブロッカー・未解決の問題
- [ ] MacのPython環境で Tkinter が利用可能か（M3 Macデフォルト想定だが、万一無効な場合は Flet などに切り替え検討）  
- [ ] ドラッグ＆ドロップ対応の具体的な実装方式（Tkinter標準 + 補助ライブラリ / 代替UI案）  

### 最近の変更履歴（直近5件）
| 日時 | 変更内容 | 関連ファイル |
|------|---------|-------------|
| 11-25 21:50 | GUI最小実装＋保存先選択＋CLI `--subtitle-dir` 追加 | `src/gui/app.py`, `src/gui/controller.py`, `src/cli/main.py`, `docs/requirement.md` |
| 11-25 21:00 | Codexによる Tkinter GUI エントリポイント初回実装を `feat/gui-tkinter` にマージ | 上記 + `src/gui/README.md` |
| 11-25 20:30 | GUI向けPLAN（簡易版）作成 → 本テンプレート版に差し替え | `docs/plan/20251125_PLAN1.md` |

---

## 💭 主要な意思決定

- **Tkinter + ttk 採用**: 追加ライブラリ不要で macOS 上でもすぐ動き、Python標準だけで最小GUIを構築できるため（代替案: Flet / Tauri+React は将来のリッチUI用に温存）。  
- **コアロジック再利用**: 文字起こし〜LLM整形〜SRT出力は `execute_poc_run` に集約し、GUI側ではパラメータを集めて渡すだけにすることで、CLI/GUI/Web の挙動差を最小化。  
- **SRT保存先はユーザー選択可能**: デフォルトは `output/` だが、GUI上から任意ディレクトリを選べるようにして、友人がプロジェクトごとに保存場所を分けやすくする。CLIでも `--subtitle-dir` で同じことができる。  
- **実行は本番モード（simulate=False）**: GUIからの実行はデフォルトで実際のモデル・LLMを使う前提とし、「お試し用のシミュレーション」は必要になったら別オプションで検討する。  
- **python.org 版 Python 3.12 前提**: Tkinter を安定して使うため、Homebrew版ではなく python.org 版3.12 + venv でGUIを動かす方針とする。  
| 11-25 00:00 | GUIフェーズ用PLANを新規作成 | `docs/plan/20251125_PLAN1.md` |
| 11-24 〜 | OpenAI SRT末尾欠落バグ対応（TwoPassFormatterフォールバック） | `src/llm/two_pass.py`, `docs/00_old/20251124_PLAN1.md` |
| 11-23 | Two-pass固定化・旧アンカー方式撤去 | `src/llm/*`, `README_REFRACTORING_SUMMARY.md` |

---

## 💭 主要な意思決定

- **Tkinter採用（初期GUI）**: 追加ライブラリ不要で macOS でも標準利用でき、まず「動くデスクトップアプリ」を短期間で用意しやすいため（代替案: Flet / Tauri + React は将来のリッチUI候補として温存）。  
- **CLIパイプラインの再利用**: 既存の `execute_poc_run` / `PocRunOptions` をそのまま利用し、GUI側では「パラメータを集めて別スレッドで実行する薄い層」にとどめる（ロジックの二重実装を避ける）。  
- **シンプルな単一ウィンドウ構成**: 画面は「ファイル選択エリア＋実行ボタン＋進捗バー＋ログテキスト」の1画面に抑え、非エンジニアユーザーが迷わないレイアウトを優先する。  

---

## 📝 変更済みファイル

| ファイルパス | 状態 | 変更内容 | 影響範囲 | 関連Phase |
|-------------|------|---------|----------|-----------|
| `src/cli/main.py` | ✅ 完了 | `gui` サブコマンド追加、`--subtitle-dir` オプション追加、Tkinterエラー時のガード実装 | CLI全体 / GUI起動方法 | Phase 1 |
| `src/gui/app.py` | ✅ 完了 | Tkinterメインウィンドウ（ファイル選択・保存先選択・実行ボタン・進捗バー・ステータス表示）の実装 | GUI UXの土台 | Phase 1 |
| `src/gui/controller.py` | ✅ 完了 | `GuiController` によるバックグラウンド実行とSRT出力パス収集 | GUI⇔パイプライン連携 | Phase 1 |
| `src/gui/README.md` | ✅ 完了 | GUIモジュールの責務と起動方法の説明 | 開発者向けドキュメント | Phase 1 |
| `docs/requirement.md` | ✅ 完了 | GUI仕様（保存先選択・CLIとの整合）と `--subtitle-dir` オプションを反映 | 要件定義 | Phase 1 |
| `docs/runbook.md` | ✅ 完了 | 主要オプション表に `--subtitle-dir` を追加 | 開発者向けRunbook | Phase 1 |
| `docs/plan/20251125_PLAN1.md` | 🔄 作業中 | 本テンプレートに沿ったPLANとして再構成 | 設計・引き継ぎ用 | Phase 0 |
| `docs/plan/20251125_PLAN1.md` | 🔄 作業中 | GUI実装用PLANの新規作成 | ドキュメントのみ | Phase 0 |
| `src/gui/app.py` | ⏳ 未着手 | Tkinterベースのメインウィンドウ実装 | GUIレイヤー | Phase 1 |
| `src/gui/controller.py` | ⏳ 未着手 | CLIパイプライン呼び出し・スレッド管理 | GUI⇔パイプライン連携 | Phase 1〜2 |
| `src/gui/README.md` | ⏳ 未着手 | GUIモジュールの責務と起動方法の説明 | 開発者向けドキュメント | Phase 0〜4 |

---

## 📋 目次

1. [要件概要](#要件概要)  
2. [技術選定](#技術選定)  
3. [アーキテクチャ設計](#アーキテクチャ設計)  
4. [実装フェーズ](#実装フェーズ)  
5. [リスクと対応策](#リスクと対応策)  
6. [完了条件](#完了条件)  
7. [🐛 トラブルシューティング・既知の問題](#-トラブルシューティング既知の問題)  
8. [参考リソース](#参考リソース)  
9. [開発引き継ぎ詳細](#開発引き継ぎ詳細)  
10. [最終ゴール](#-最終ゴール)  

---

## 要件概要

### 背景・目的
CLI からの利用は整っているものの、非エンジニアの友人にとって「ターミナル操作」は心理的ハードルが高い。  
このフェーズでは、**PythonをインストールしてGUIを起動するだけで、音声→SRT生成まで完結できるデスクトップアプリ**を用意する。  
将来的には Web UI（ブラウザ）版も視野に入れつつ、まずはデスクトップ版で体験を固める。

### 実装する機能
- **[GUI起動]**: `python -m src.cli.main gui` で Tkinterウィンドウを起動。  
- **[ファイル入力]**: ファイル選択ダイアログから音声ファイルを指定。  
- **[保存先選択]**: デフォルト `output/` だが、GUI上の「保存先を変更」ボタンから任意フォルダを選択可能。  
- **[実行ボタン]**: `execute_poc_run` をバックグラウンドで実行し、SRTを生成。  
- **[ステータス表示]**: 「待機中」「処理中…」「完了しました」「エラーが発生しました」をGUI上で表示。  

### スコープ外
- GUIでの詳細ログ閲覧、実行履歴管理、複数ファイル一括処理などの高度な機能。  
- Webフロントエンド（ブラウザ上の画面）の実装（フェーズ4以降で検討）。  
- `.app` パッケージングと配布フローの詳細（別PLANまたは別セクションで扱う）。  

---

## 技術選定

### 新規導入ライブラリ

現時点では **Tkinter（標準ライブラリ）＋ ttk** のみを使用し、外部GUIライブラリは導入しない。

| ライブラリ | バージョン | 選定理由 |
|-----------|-----------|---------|
| `tkinter` / `ttk` | Python標準（3.12系） | 追加インストール不要、macOSでTkinter同梱の公式Pythonが入っていれば動作するため |

### 既存ライブラリの活用
- `src/pipeline/poc.py` の `execute_poc_run`: GUI/CLI/Webすべてから共通利用する中核。  
- `src/config/settings.py`: LLMやタイムアウトなどの設定をenvから取得。GUIでも同じ値を利用。  
- `src/llm/two_pass.py`: LLM整形ロジックはすべてここに閉じ込め、UI層からは触らない。  

---

## アーキテクチャ設計

### 1. ディレクトリ構造
現在は CLI からコマンドを実行することで音声→SRT 生成が可能だが、非エンジニアユーザー（友人）にとっては「ターミナル操作」が心理的ハードルになっている。  
このフェーズでは、**ドラッグ＆ドロップまたはファイル選択だけで処理を実行できる簡単なデスクトップアプリ**を用意し、日常的に迷わず使える体験を提供する。

### 実装する機能
- **[GUI起動]**: ダブルクリック or `python -m src.cli.main gui` で起動できる単一ウィンドウのGUI。  
- **[ファイル入力]**: 音声ファイルをファイル選択ダイアログ（将来的にはドラッグ＆ドロップ対応）で指定できる。  
- **[実行ボタン]**: 「実行」ボタンを押すと、既存パイプラインを呼び出して文字起こし〜SRT生成を行う。  
- **[進捗表示]**: 「音声解析中…」「AI思考中…」「ファイル生成中…」のステータスと進捗バーを表示。  
- **[結果パスの案内]**: 処理完了後に、生成された SRT ファイルの保存場所（`output/` 下）をGUI上で分かりやすく表示。  

### スコープ外
- 3モデル（mlx / kotoba / openai）の詳細な切り替えUI（初期版ではデフォルト設定優先）。  
- GUI上での詳細ログ閲覧機能（CLIログは従来どおりファイルに保存）。  
- .app への完全パッケージングやインストーラー配布（Phase 4 で検討）。  

---

## 技術選定

### 新規導入ライブラリ

現時点では **Tkinter（標準ライブラリ）＋ ttk** の利用のみを想定し、追加の外部GUIライブラリは導入しない方針とする。

| ライブラリ | バージョン | 選定理由 |
|-----------|-----------|---------|
| `tkinter` / `ttk` | Python標準 | 追加インストール不要で macOS 上でも利用しやすく、最小限のGUIを素早く構築できるため |

※ 将来的に UI をモダンにしたい場合は、`customtkinter` や Flet などを別PLANとして検討する。  
※ ブラウザで動く Web アプリ版を作りたくなった場合は、「Tkinter を捨てて作り直す」のではなく、既存の `execute_poc_run` などのコア処理をそのまま FastAPI 等のAPIから呼び出す構成を想定しておく（= Tkinter はあくまで「最初の入口」の1つ）。 

### 既存ライブラリの活用
- `src/pipeline/poc.py`: 既存の `execute_poc_run` / `PocRunOptions` を GUI から直接呼び出し、ロジックを再利用。  
- `src/utils/progress.py`: 進捗JSONの仕組みはそのまま利用し、GUI側のステータス表示に一部反映する可能性あり。  
- `src/llm/two_pass.py`: LLM整形は既存の two-pass フローをそのまま利用（GUIからはオプションのみ制御）。  

---

## アーキテクチャ設計

### 1. ディレクトリ構造（GUI関連）

```text
src/
├── cli/
│   └── main.py              # Typer CLI（run / cleanup / gui）
├── pipeline/
│   └── poc.py               # 音声→LLM整形→SRT出力の中核ロジック
├── gui/
│   ├── __init__.py
│   ├── app.py               # Tkinterメインウィンドウ（MainWindow / run_gui）
│   ├── controller.py        # GuiController: execute_poc_run をバックグラウンドで実行
│   └── README.md            # GUIモジュールの説明と起動方法
└── llm/, transcribe/, alignment/ ...  # 既存ロジック（触らない）
│   └── main.py              # 既存CLI（run / cleanup / gui サブコマンド）
├── pipeline/
│   └── poc.py               # 音声→LLM整形→SRT出力の中核ロジック
├── gui/
│   ├── __init__.py          # GUIパッケージ初期化
│   ├── app.py               # Tkinter エントリーポイント（MainWindow定義）
│   ├── controller.py        # GUIからパイプラインを呼ぶコントローラ（別スレッド実行）
│   └── README.md            # GUIモジュールの概要と起動方法
└── alignment/
    └── srt.py               # SubtitleSegment → SRT 変換ユーティリティ
```

### 2. データフロー

```text
GUI(MainWindow)
  ├─ ファイル選択ダイアログで audio_path を取得
  ├─ 保存先フォルダ（subtitle_dir）をUIで指定（未指定なら output/）
  └─ GuiController.run_pipeline(audio_path, subtitle_dir, callbacks...)
         │
         ├─ ensure_audio_files()
         ├─ resolve_models()
         ├─ execute_poc_run()
         └─ SRTファイル出力 + 進捗JSON出力
```

GUI は「入力パラメータの収集」と「状態表示」に専念し、処理本体は `execute_poc_run` に任せる。

### 3. 主要コンポーネント

- **`MainWindow` (`src/gui/app.py`)**  
  - 役割: ユーザーに見えるウィンドウ（ファイル選択・保存先選択・実行・ステータス表示）。  
  - 主な要素:  
    - ラベル: 選択中の音声ファイルパス / 保存先フォルダ  
    - ボタン: 「ファイルを選択」「保存先を変更」「実行」  
    - プログレスバー: インジケータ表示（処理中かどうか）  
    - ステータスラベル: 状態メッセージ表示  

- **`GuiController` (`src/gui/controller.py`)**  
  - 役割: GUIからパイプラインを別スレッドで実行し、完了時にコールバックを呼ぶ。  
  - 責務:  
    - `PocRunOptions` の構築（simulate=False / subtitle_dir反映）  
    - `execute_poc_run` の呼び出し  
    - 実行中・完了時のコールバックをUIスレッドで呼び出す（`ui_dispatch`利用）  

---

## 実装フェーズ

### Phase 0: 事前準備・設計
- [x] 要件定義書（`docs/requirement.md`）と既存PLANの確認  
- [x] GUIフェーズ用PLAN（本ドキュメント）の作成・テンプレート適用  
- [x] python.org版3.12 + Tkinterを前提とする方針決定  

### Phase 1: 最小GUI（ファイル選択＋実行ボタン＋保存先選択）
- [x] `src/gui/app.py` 実装 - MainWindow（ファイル選択・保存先選択・実行ボタン・ステータス・プログレスバー・メトリクス表示）  
- [x] `src/gui/controller.py` 実装 - GuiController（バックグラウンド実行＆SRTパス収集＋メトリクスサマリ集計）  
- [x] `src/cli/main.py` に `gui` サブコマンド追加・Tkinter環境チェック実装  
- [x] `src/cli/main.py` に `--subtitle-dir` オプション追加  

**実装のポイント**:
- GUI側ではロジックを持たず、必ず `execute_poc_run` を呼び出す。  
- Tkinter がない環境では `gui` コマンドだけがエラーになり、他のCLIは動作し続けるようにガードする。  

### Phase 2: ステータス詳細化（工程別表示）
- [ ] パイプライン内のログ・進捗情報（音声解析 / LLM整形 / SRT出力）をGUIに反映する設計を決める。  
- [ ] GUIステータスを「音声解析中…」「AI思考中…」「ファイル生成中」に分けて表示。  
- [ ] 長尺音声でのUXを軽く検証（ステータスの変化タイミングが分かるか）。  

### Phase 3: オプションUI追加（プリセット＋詳細モード）
- [x] 「モデルプリセット」プルダウンを追加し、`config/llm_profiles.json` に定義した LLMプロファイル一覧を選べるようにする（例: `default`, `openai_gpt5`）。  
- [x] 選択されたプリセットをもとに、`PocRunOptions.llm_profile` と `llm_pass1_model`〜`llm_pass4_model` を設定する。  
- [x] 「詳細設定」エリア（折りたたみ）を追加し、Pass1〜4 のモデル名を **プルダウン（Combobox）** から選択できるようにする（候補はプロファイル定義から自動生成）。  
- [ ] リライトON/OFFチェックボックス → `rewrite` に連動。  
- [ ] LLMプロバイダー選択プルダウン（google / openai / anthropropic） → `--llm` 相当。  
- [ ] 高精度モードON/OFF → `models` / ランナー構成に連動（詳細は別途設計）。  

### Phase 4: Web UI / パッケージング検討
- [ ] FastAPIなどで `execute_poc_run` を包むAPIの設計検討。  
- [ ] Webフロント（簡易画面）を別リポジトリ or `web/` ディレクトリで管理するか決める。  
- [ ] Mac向け `.app` 化（PyInstaller / py2app など）のPoCを行い、**MLX Whisper runtime（mlx-whisper）をアプリ内に同梱**して配布できることを確認する。  
- [ ] Windows向け配布形態（Whisper Large-v3ローカル実行用の `.exe` など）について、別PLANとして要件と手段を検討する。  

---

## リスクと対応策

| リスク | 内容 | 対応策 |
|-------|------|--------|
| Tkinterが環境依存で動かない | Homebrew版Pythonなどでは `_tkinter` が入っていないケースがある | python.org 版3.12を前提とし、`gui` コマンドでImportErrorを検知してメッセージを出す |
| 長尺音声でGUIが固まって見える | バックグラウンド実行でも、ユーザーからすると何が起きているか分かりにくい | Phase 2で工程別ステータスを実装し、処理段階が分かるようにする |
| 保存先フォルダを間違える | CLI/GUIともにデフォルト `output/` だが、ユーザーが別フォルダを指定して迷子になる可能性 | GUIでは保存先ラベルを常に表示し、CLIでもPRやREADMEで保存先の例を明記する |
| .app 化時のトラブル | Gatekeeper 等でアプリが開けない | パッケージングは別フェーズとし、まず開発環境でのGUI安定稼働を優先する |

---

## 完了条件

### 機能要件
- [ ] `python -m src.cli.main gui` でTkinterウィンドウが起動する。  
- [ ] GUIから音声ファイルを選択→実行ボタンでSRTが生成される（デフォルト `output/` または指定フォルダ）。  
- [ ] CLIから `--subtitle-dir` を指定した場合も、指定フォルダにSRTが出力される。  
- [ ] エラー発生時に分かりやすいメッセージがGUIに表示される。  
- [ ] 実行完了後、GUI下部に「総トークン数」「概算APIコスト（USD、小数点第3位まで）」「総処理時間（X分Y秒）」が表示される。  

### 品質要件
- [ ] GUI経由でもCLIと同じtwo-pass整形ロジックが使われる（SRT品質が一致）。  
- [ ] Tkinter環境が無い場合でもCLIの他コマンド（`run`, `cleanup`）は問題なく動作する。  

### ドキュメント
- [ ] `docs/requirement.md` が実装内容に追従している。  
- [ ] 本PLAN（`docs/plan/20251125_PLAN1.md`）が最新状態になっている。  

---

## 🐛 トラブルシューティング・既知の問題

### エラー1: `_tkinter` が見つからない
**症状**: `ModuleNotFoundError: No module named '_tkinter'` が出てGUIが起動しない。  
**原因**: Homebrew版Pythonなど、Tkinter未同梱のPythonで仮想環境を作成している。  
**解決策**: python.org 版3.12をインストールし、そのPythonでvenvを作り直す。  
**参考**: `src/cli/main.py` 内の `launch_gui` でエラーメッセージを出す。  

### 注意ポイント1: 実行ボタンの連打
**問題**: 実行ボタンを連打すると複数スレッドが立ち上がり、結果が混ざる可能性。  
**対応**: 実行中は `run_button` を無効化し、完了後に再度有効化する実装済み。  
GUI(MainWindow) → Controller → execute_poc_run(PocRunOptions) → TwoPassFormatter → SRTファイル出力
                    │
                    └→ GUIへ進捗・完了イベントをコールバック
```

ポイント:
- GUIスレッドは画面更新のみに専念し、パイプライン実行は `threading.Thread` などでバックグラウンド実行。  
- 実行中は「実行ボタンを無効化」「キャンセルボタンは別Phaseで検討」とし、誤操作を防ぐ。  
 - 将来 Web アプリ版を作る場合は、`Controller` 相当の役割を持つ「Web用API（例: FastAPIのエンドポイント）」を追加し、同じ `execute_poc_run` を呼び出すだけで済むようにする（GUIごとにロジックを書き直さない）。

### 3. 主要コンポーネント

- **`MainWindow`（Tkinter）**:  
  - 役割: ファイル選択エリア、実行ボタン、進捗バー、簡易ログラベルを配置するメインウィンドウ。  
  - 主な要素: ファイルパス表示ラベル、`実行`ボタン、`進捗バー(ttk.Progressbar)`, ステータステキスト。  

- **`GuiController`**（controller.py）:  
  - 役割: `execute_poc_run` を別スレッドで呼び出し、進捗状況・完了・エラーを GUI に通知する。  
  - 主なメソッド: `run_pipeline(audio_path, options, callbacks)`。  

---

## 実装フェーズ

### Phase 0: 事前準備・設計（0.5日）
- [ ] 本PLANの内容をユーザーと軽く確認し、「Tkinterベースで最小GUIから着手」方針を合意する。  
- [ ] `src/gui/README.md` に、GUIモジュールの目的と簡単なアーキテクチャを記述。  

### Phase 1: 最小GUI（ファイル選択＋実行ボタン）（1日）
- [ ] `src/gui/app.py` に Tkinter メインウィンドウを実装。  
  - [ ] ファイル選択ボタン（`tkinter.filedialog.askopenfilename`）で音声ファイルを選択。  
  - [ ] 選択済みファイルパスをラベルで表示。  
- [ ] `src/gui/controller.py` を追加し、`execute_poc_run` を別スレッドから呼び出せるようにする。  
- [ ] CLI に `gui` サブコマンドを追加し、`python -m src.cli.main gui` でGUIを起動できるようにする。  

**実装のポイント**:
- GUIからパイプラインを呼ぶ際も、`PocRunOptions` を通して既存オプション構造を尊重する。  
- 初期版ではエラーメッセージを簡潔なダイアログ（`messagebox.showerror`）で表示する。  

### Phase 2: 進捗バー・ステータス表示（1日）
- [ ] パイプライン実行中に、GUI上で「音声解析中…」「AI思考中…」「ファイル生成中…」のステータスを表示。  
  - （実装案）パイプライン実行前後／SRT書き出し前後で Controller から GUI にイベント通知。  
- [ ] 簡易な進捗バー（インジターミネイトでも可）を追加。  
- [ ] 実行完了時に、生成された SRT ファイルのパスと「完了しました」メッセージを表示。  

### Phase 3: オプションUI追加（1〜2日）
- [ ] 「語尾調整・リライトを行う」チェックボックス → `rewrite` オプションに連動。  
- [ ] 「高精度モード（large-v3）」チェックボックス → `models` / ランナー設定に連動（詳細はCLI仕様と同期）。  
- [ ] LLMプロバイダー（`--llm`）の選択UI（Google/OpenAI/Anthropic）を導入するか検討し、必須であればプルダウンで実装。  

### Phase 4: パッケージング・ドキュメント（1〜2日）
- [ ] `docs/runbook.md` に GUI 起動方法を追記。  
- [ ] `.app` 化の方針検討（py2app / PyInstaller など）と、別PLANへの切り出しの要否を決定。  
- [ ] 友人向け「使い方ガイド」（スクリーンショット付き）を簡易に作成。  

**合計見積もり**: 3〜5日（GUIの見た目やオプションの範囲により変動）  

---

## リスクと対応策

| リスク | 内容 | 対応策 |
|-------|------|--------|
| **Tkinterの見た目が素朴すぎる** | UIが古く感じられ、長期的には使いづらい可能性 | 初期版は機能優先で割り切り、後から customtkinter / Flet などで「見た目改善PLAN」を別途立てる |
| **処理中にGUIが固まる** | 音声処理が重く、メインスレッドをブロックするとウィンドウがフリーズする | パイプラインは必ず別スレッドで実行し、GUI側はイベント駆動＋`after` で状態更新する |
| **ドラッグ＆ドロップ実装の難易度** | Tkinter標準だけでは D&D のUXが限定的 | 初期版では「ファイル選択ボタン」で代替し、D&Dは Phase 3 以降で段階的に導入（必要ならサードパーティ利用も検討） |
| **macOS特有の制約** | Gatekeeper や .app 化時の設定で動かないケース | パッケージングはPhase4の別タスクとし、まずは「開発環境でGUIが動く」状態を優先する |

---

## 完了条件

### 機能要件
- [ ] GUI起動が `python -m src.cli.main gui` で行える。  
- [ ] GUI上で音声ファイルを選択し、「実行」ボタンだけでSRTが生成される。  
- [ ] 処理中にステータス表示（最低3ステップ: 音声解析中 / AI思考中 / ファイル生成中）が更新される。  
- [ ] エラー発生時に、ユーザーが理解しやすいメッセージ（例: 「ネットワークエラーが発生しました」）がダイアログで表示される。  

### 品質要件
- [ ] 既存CLIと同じSRT品質（1行17文字以内＋自然な区切り）を維持。  
- [ ] GUI操作で CLI 側の挙動が壊れていない（既存CLIコマンドも問題なく動作）。  
- [ ] Python実行時にGUI関連の例外がコンソールに大量に出ない。  

### ドキュメント
- [ ] `docs/runbook.md` に GUI 起動手順を追記。  
- [ ] `src/gui/README.md` に構成と責務を書き残す。  

---

## 🐛 トラブルシューティング・既知の問題

### 想定されるトラブル例（草案）

#### エラー1: GUIが起動しない（Tkinter関連エラー）
**症状**: `ModuleNotFoundError: No module named 'tkinter'` などがコンソールに出る。  
**原因**: Pythonのインストールに Tkinter が含まれていない、または無効化されている。  
**解決策**: macOS の Python を公式サイト版に切り替える、または Tkinter を含むPythonを再インストールする。  
**参考**: `src/gui/README.md` に環境構築メモを追記予定。  

#### 注意ポイント1: 音声処理中の連打
**問題**: 実行ボタンを連打すると、複数スレッドが走り予期しない挙動になる可能性。  
**対応**: 実行中はボタンを無効化し、完了後に再度有効化する。  
**影響ファイル**: `src/gui/app.py`, `src/gui/controller.py`  

---

## 参考リソース

### 公式ドキュメント
- Tkinter / ttk 基本: Python公式ドキュメント（`tkinter` モジュール）  
- FlowCut Runbook: `docs/runbook.md`  
### 公式ドキュメント・リファレンス
- Tkinter / ttk 基本: Python公式ドキュメント（`tkinter` モジュール）  
- 既存プロジェクトRunbook: `docs/runbook.md`  

### 関連プランドキュメント
- `docs/00_old/20251124_PLAN1.md`（OpenAI LLM SRT部分出力バグ修正）  
- `docs/00_old/20251125_PLAN1.md`（LLMプロンプトワークフロー切り替え機能）  

---

## 開発引き継ぎ詳細

### 📌 承認内容
- [x] GUIはまず Tkinter で最小構成を作り、将来必要なら customtkinter / Flet / Web UI でリッチ化する。  
- [x] ロジックは `execute_poc_run` に集約し、UI層では再実装しない。  

### 🗂️ プロジェクト状態
- **技術スタック**: Python 3.12（python.org） / Typer CLI / Tkinter GUI / MLX Whisper / Two-pass LLM整形  
- **動作確認済み機能**: CLIベースの文字起こし〜SRT生成、Tkinter最小GUIからの実行  
- **既知の問題**: 長尺音声でのUX改善（工程別ステータス表示）は今後のPhaseで対応予定。  

### 🚀 実装優先順位

1. **Phase 2** - 理由: 「動いていること」が分かるだけでなく「どの段階か」も見えるようにして不安を減らすため  
2. **Phase 3** - 理由: LLMやリライト設定をGUIから切り替えられると、友人の実運用時に便利なため  
3. **Phase 4** - 理由: Web UIやパッケージングは基盤が安定してからでよい（優先度はCLI/GUIの安定性が先）  

### ⚠️ 重要な注意事項

- GUI実装時は必ず `execute_poc_run` の呼び出し方を変えないようにする（挙動比較がしやすい）。  
- エラー文言はユーザー向けにはやさしい日本語で、詳細はログに任せる。  

---

## 🎯 最終ゴール

**ユーザー体験**:
1. アプリ（スクリプト）を起動する。  
2. 音声ファイルと保存先フォルダをGUI上で選ぶ。  
3. 「実行」ボタンを押すと、ステータスが変化し、処理完了後にSRTファイルの場所が表示される。  

**技術的ゴール**:
- CLI / GUI / 将来のWeb UIが同じパイプラインを通って動作する。  
- Tkinter環境があれば、非エンジニアでもターミナル操作なしで FlowCut を使える。  
- 後からWeb版やパッケージングを追加しても、コアロジックを触らずに済むアーキテクチャになっている。  

---

**実装準備完了！🚀**  
Phase 1 の実装は完了しているので、次は Phase 2（工程別ステータス表示）の詳細設計と実装に進める状態です。  
### 📌 承認内容（想定）
- [ ] GUIはまず Tkinter で最小構成を作り、後から見た目改善を検討する。  
- [ ] ロジックは必ず `execute_poc_run` を経由して呼び出し、CLIとGUIで処理内容を揃える。  

### 🗂️ プロジェクト状態
- **技術スタック**: Python 3.12 / Typer CLI / Tkinter GUI / MLX Whisper / Two-pass LLM整形  
- **動作確認済み機能**: CLIベースの文字起こし〜SRT生成（two-pass固定）  
- **既知の問題**: 長尺音声時のUX（時間がかかる間の体験）は今後GUIで改善予定。  

### 🚀 実装優先順位

1. **Phase 1** - 理由: 「とりあえず使えるGUI」を最短で提供するため  
2. **Phase 2** - 理由: 進捗表示がないと長尺処理で不安になるため  
3. **Phase 3** - 理由: リライト・高精度モードなどのオプションは利便性向上フェーズとして後追いで実装  

### ⚠️ 重要な注意事項

- **CLIとの整合性**: GUI独自のロジックを増やしすぎず、常にCLIルートと挙動を比較できるようにする。  
- **エラー表示**: スタックトレースは開発者向けログに留め、ユーザーには要約したメッセージだけを見せる。  

---

## 🎯 最終ゴール

**ユーザー体験（友人視点）**:
1. アプリ（またはスクリプト）を開く。  
2. 音声ファイルを選択して「実行」ボタンを押す。  
3. 少し待つと、「完了しました」と表示され、同じフォルダ内（または `output/`）にSRTが生成されている。  

**技術的ゴール**:
- GUIからの操作でも、CLIと同じ品質のSRTを安定して生成できる。  
- Two-pass LLM整形やメトリクス収集など、既存のバックエンド機能をそのまま活かした構成になっている。  
- 将来的な見た目改善（customtkinter / Flet / Tauri など）や .app 化にスムーズに発展できる土台が整っている。  

---

**実装準備完了！🚀**  
このPLANをベースに、次ステップとして Phase 1（最小GUI）のコード実装に着手できます。ユーザーの確認後、ブランチ作成・Draft PR 作成フローに進んでください。  
